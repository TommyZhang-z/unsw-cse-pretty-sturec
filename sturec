#!/usr/bin/python3


import argparse
import re
import subprocess
import pkg_resources
import typing as t
from rich import box
from rich.color import Color
from rich.console import Console
from rich.markdown import Markdown
from rich.style import Style
from rich.table import Table

# Constants
WIDTH = 65

dependencies = [
    'rich>=12.4.4',
]

pkg_resources.require(dependencies)

# Type aliases
t_stderr = t.AnyStr
t_stdout = t.AnyStr
t_error = t.Union[BaseException, None]

# Predicate type alias
t_read_predicate = t.Callable[[t.Any, t.Any], bool]


class t_class_info(t.TypedDict):
    course_alpha: str
    course_code: int
    term: int
    role: str
    expiry: str


def run_shell_command(command: str) -> t.Tuple[t_stdout, t_stderr]:
    result = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        shell=True
    ).communicate()
    return list(map(lambda x: x.decode("utf-8"), result))


def run_command(cs_class_number: str) -> t.Tuple[t_stdout, t_stderr]:
    return run_shell_command(f"{cs_class_number} classrun -sturec")


def get_default_class() -> str:
    stdout, stderr = run_shell_command("acc format=\'$CLASSES\'")
    if stderr:
        exit(1)
    classes = stdout.strip().split(",")

    # Stores the alpha (e.g. COMP) and the code (e.g. 2521) as tuples.
    courses: t.List[t_class_info] = []

    for c in classes:
        parsed = parse_class(c)
        if parsed:
            if parsed["course_alpha"].lower() != "comp":
                print(f"Class {parsed['course_alpha']} is not supported.")
                continue
            courses.append(parsed)

    if len(courses) == 0:
        print("Could not find any supported classes.")
        exit(1)

    if len(courses) == 1:
        return courses[0]["course_code"]

    # Prints a table of the courses and their codes.
    table = Table(width=WIDTH, box=box.DOUBLE)
    table.add_column("Selection", style=Style(bold=True))
    table.add_column("Course")
    table.add_column("Code")
    table.add_column("Term")
    table.add_column("Role")
    table.add_column("Expiry")
    for i, course in enumerate(courses):
        table.add_row(str(i), course["course_alpha"], str(course["course_code"]),
                      f'Term {course["term"]}', course["role"], str(course["expiry"]))
    console.print(table)
    console.print(
        f"[green] You're enrolled in multiple classes. Please select one [{0}-{len(courses)-1}]: [/green]", end='')
    selection = input("")
    try:
        selection = int(selection)
    except ValueError:
        console.print("[red] Invalid selection. [/red]")
        exit(1)

    if selection < 0 or selection >= len(courses):
        console.print("[red] Invalid selection. [/red]")
        exit(1)

    return courses[selection]["course_code"]


def read_iter(iter: t.Iterator, length: int = 0, until: str = None,
              predicate: t_read_predicate = lambda a, b: a == b,
              discard_until_element: bool = False, enforce_length=False) -> t.List[t.Any]:
    '''
    Attempts to read the given iterator for max length of n, until 
    StopIteration is raised or the the desired object is found. If n is zero, 
    there will be no limit on the length of the read.

    Returns List[val]. StopIteration will not be treated as an exception, 
    unless specified using the enforce_length param.
    '''
    acc = []
    length_read = 0

    while length_read < length or length == 0:
        try:
            val = next(iter)
            acc.append(val)
            if until and predicate(val, until):
                if discard_until_element:
                    acc.pop()
                return acc, None
        except StopIteration:
            return acc, None
        except BaseException as e:
            return acc, e
        length_read += 1
    return acc, None


def check_error(err: t_error) -> None:
    if err:
        raise err


def parse_class(c: str) -> t.Union[t_class_info, None]:
    '''
    Parses the class record in the format:
    <class(4, alpha)><class_code(4, int)>t<term(1, int)>_<role(?, char)>[expiry(8, str)]

    Example:
    COMP2521t2_Student[20220926]

    Returns a dictionary containing the parsed data, or None if the class is
    not in the format above.
    '''

    try:
        it = iter(c)
        course_alpha, err = read_iter(it, length=4, enforce_length=True)
        check_error(err)
        course_alpha = ''.join(course_alpha)
        course_code, err = read_iter(it, length=4, enforce_length=True)
        check_error(err)
        course_code = int(''.join(course_code))
        _, err = read_iter(it, length=1, enforce_length=True)
        term, err = read_iter(it, length=1, enforce_length=True)
        check_error(err)
        term = int(term[0])
        check_error(err)
        _, err = read_iter(it, length=1, enforce_length=True)
        role, err = read_iter(it, until="[", discard_until_element=True)
        check_error(err)
        role = ''.join(role)
        expiry, err = read_iter(it, length=8, enforce_length=True)
        check_error(err)
        expiry = ''.join(expiry)
        return {
            "course_alpha": course_alpha,
            "course_code": course_code,
            "term": term,
            "role": role,
            "expiry": expiry
        }
    except Exception:
        return None


def re_parse(s: str) -> t.Dict[str, t.Union[str, t.Dict[str, str]]]:
    data = {}
    data['ClassKey'] = re.search(r"ClassKey: (\S+)", s).group(1)
    data['StudentID'] = re.search(r"StudentID: (\S+)", s).group(1)
    last_name, first_name = re.findall("Name: (\S+), (\S+)", s)[0]
    data['Name'] = {"first_name": first_name, "last_name": last_name}
    data['Program'] = re.search(r"Program: (\S+)", s).group(1)
    data['Plans'] = re.search(r"Plans: (\S+)", s).group(1)
    data['Login'] = re.search(r"Login: (\S+)", s).group(1)
    data['tut_lab'] = re.search(r"tut_lab: (\S+)", s).group(1)
    return data


def helper(s: str) -> t.Union[float, None]:
    return None if s in ".?" else float(s)


if __name__ == "__main__":
    console = Console(width=WIDTH)

    parser = argparse.ArgumentParser()
    parser.add_argument("classname", nargs="?")
    args = parser.parse_args()
    classname = args.classname
    if not classname:
        classname = get_default_class()

    # status loading animation
    with console.status("[bold green]Loading...") as status:
        stdout, stderr = run_command(classname)
        if (stderr):
            console.print(
                f"[red]Could not load the marks for class {classname}.[/red]")
            exit(1)

        data = re_parse(stdout)
        lines = re.split(r"\n", stdout)

        first_name, last_name = data['Name'].values()

        table = Table(width=WIDTH, box=box.DOUBLE)

        test_style = Style(color=Color.from_rgb(58, 170, 197))
        table.add_column("Test", justify="left",
                         style=test_style, no_wrap=True, min_width=20)
        table.add_column("Mark", justify="left")
        table.add_column("Status", justify="left", style="white")

        # ignore first line
        for line in lines[1:]:

            # ignore empty lines
            if not line:
                continue

            result = re.split(r":\s", line.rstrip())

            # ignore lines with useless data
            if (len(result) != 2):
                continue

            test_name, score_prompt = result
            if re.search("\d+$", score_prompt) and test_name not in data.keys():
                score, total = list(map(helper, re.split(r"/", score_prompt)))

                # must use score is None since "not score" also pass when score == 0
                if score is None:
                    table.add_row(test_name, score_prompt, "TBA")
                elif score == total:
                    table.add_row(test_name, score_prompt, "ðŸ”¥")
                else:
                    table.add_row(test_name, score_prompt,
                                  "[green]:heavy_check_mark:[/green]")

    MARKDOWN = f"""
# Student Record
-  **Name**    :  {first_name} {last_name}
-  **zID**     :  {data.get("Login", "?")}
-  **Course**  :  {data.get("ClassKey", "?")}
-  **Tut/Lab** :  {data.get("tut_lab", "?")}
-  **Program** :  {data.get("Program", "?")}
-  **Plans**   :  {data.get("Plans", "?")}
"""
    md = Markdown(MARKDOWN)

    # displaying results
    console.print(md)
    console.print("")
    console.print(table)
